设计模式的七大原则：

开闭原则：
    软件应该对扩展开放，对修改关闭。
作用：
    降低软件的维护成本，增加可扩展性。

里氏替换原则：
    里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化。
    子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
作用：
    里氏替换原则是实现开闭原则的重要方式之一。
    它克服了继承中重写父类造成的可复用性变差的缺点。
    它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

依赖倒置原则：
    面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象。
作用：
    降低类间的耦合性，使系统更适宜于扩展，也更便于维护。

单一职责原则：
    一个类应该只有一个发生变化的原因。职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
    如果一个对象承担了太多的职责，至少存在以下两个缺点：
        1、一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力
        2、当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费
    核心就是控制类的粒度大小、将对象解耦、提高其内聚性
    与接口隔离原则的区别：注重的是职责，主要是约束类，它针对的是程序中的实现和细节
作用
    降低类的复杂度、耦合度，提高类的内聚性
    提高代码的可读性，维护性
    减低代码出错的风险


接口分离原则：
    使用多个专门的接口，而不使用高耦合的单一接口。
    要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
    与单一职责原则的区别：注重的是对接口依赖的隔离，主要约束接口，主要针对抽象和程序整体框架的构建
作用
     降低接口的复杂度、耦合度


迪米特法则（最少知道原则）：
    一个实体应当尽量少地与其他实体之间发生相互作用。
    如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
    含义：只与你的直接朋友交谈，不跟“陌生人”说话。“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，
    这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
作用：
    为了降低耦合，提高模块的相对独立性。
    由于亲合度降低，从而提高了类的可复用率和系统的扩展性。


合成复用原则（组合/聚合复用原则）：
    软件复用时，要尽量先使用组合或者聚合等关联关系来实现
    通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用
作用：
    通常类的复用分为继承复用和合成复用两种.

    继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
    继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
    子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
    它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

    采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
    它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
    新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
    复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。



23种设计模式：


创建型模式（五种）:

    建议根据业务复杂度去使用对应的工厂模式
    两种实现方式（一种是传参数获取，一种是直接调方法获取）常用的是传参方式

    工厂方法模式 (Factory)
        1、简单工厂模式：（常用）
            定义：定义一个创建对象的类，由这个类来封装实例化对象的行为。
            存在的问题：如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则（问题不大）
            用来生产同一等级结构中的任意产品。（不支持拓展增加产品）
        2、工厂方法模式：（业务可用）
            定义：用一个工厂类管理各个子工厂类
            用来生产同一等级结构中的固定产品。（支持拓展增加产品）
        3、抽象工厂模式：（继承接口或抽象类） （简单来说就是工厂的工厂）（建议使用）
            定义：定义了一个接口或抽象类用于创建对象族（工厂），获取到工厂后，再决定获取对应的实例对象。
            优点：便于扩展
            用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）


    建造者模式 (Builder)
        定义：封装一个复杂对象构造过程，并允许按步骤构造。
        定义解释：一个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，
        但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离， 使用builder模式可以建立。

        四种角色：
        1、产品(Product)：要构造的复杂对象；
        2、抽象生成器(Bulider)：抽象生成器是一个接口，该接口除了为创建一个Product对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法（定义构造步骤）；
        3、具体生产器(ConcreteBuilder)：实现Builder接口的类，具体生成器将实现Builder接口所定义的方法（生产各个组件）；

        4、指挥者(Director)：指挥者是一个类，该类需要含有Builder接口声明的变量。
        指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的Product对象，
        如果所请求的具体生成器成功地构造出Product对象，指挥者就可以让该具体生产器返回所构造的Product对象。（按照步骤组装部件，并返回Product）

        优点：将一个对象分解为各个组件，将对象组件的构造封装起来，可以控制整个对象的生成过程
        缺点：对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量


    原型模式 (Clone)
        定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。（本质是Clone） （深拷贝和浅拷贝）

    单例模式 (Singleton)
        定义：确保一个类最多只有一个实例，并提供一个全局访问点
        单例模式可以分为两种：预加载和懒加载
        预加载:还没有使用该单例对象，就已经被加载到内存了。
        懒加载：需要保证线程安全性


结构型模式（7种）

    适配器模式 (Adapter)
        定义：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

        主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。
        类适配器模式：通过多重继承目标接口和被适配者类方式来实现适配。
        对象适配器模式：对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。
        接口适配器模式：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），
                    那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。

        类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
        对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
        接口适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。

        使用选择：根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。


    装饰模式 (Decorator)
        定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。
        简单解释：将对象封装到另一个对象中，用以为原对象绑定新的行为。
        角色：被装饰者与装饰者
        1.Component（被装饰对象的基类）
           定义一个对象接口，可以给这些对象动态地添加职责。
        2.ConcreteComponent（具体被装饰对象）
           定义一个对象，可以给这个对象添加一些职责。
        3.Decorator（装饰者抽象类）
           维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。
        4.ConcreteDecorator（具体装饰者）
           具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。

        装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。
        在这里应用继承并不是实现方法的复制,而是实现类型的匹配。
        因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。
        根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。


    代理模式 (Proxy)
        定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
        中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，
                   而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。
        开闭原则，增加功能：我们还可以通过给代理类增加额外的功能来扩展委托类的功能，通过调用委托类的相关方法，来提供特定的服务。
                    可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能。

        代理模式分为三类：
        1. 静态代理
            缺点：代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，造成太多的类存在。
        2. 动态代理 3. CGLIB代理 (go 语言没有，如需要得自己模拟实现)


    外观模式 (Facade)
        定义： 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。
        三种角色：
        　　1）.门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（客户调用，同时自身调用子系统功能）
        　　2）.子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）
        　　3）.客户角色:通过调用Facede来完成要实现的功能（调用门面角色）。
        优点：
            1、使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护
            2、有些方法是对系统外的，有些方法是系统内部相互交互的使用的。
                子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。

           　

    桥接模式 (Bridge)
        定义： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
        适用场景：
            当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
            当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
            当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。

        优点：
            (1)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，
                且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。
            (2)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。
        缺点：
            增加系统的理解与设计难度


    组合模式（对象树模式）(Object Tree)
        定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，
            用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
            可以利用多态和递归机制更方便地使用复杂树结构。

        意图：将对象组合成树形结构以表示"部分-整体"的层次结构。
            组合模式使得用户对单个对象和组合对象的使用具有一致性。

        透明组合模式：
            由于 Component 包含叶子节点所不需要的方法，因此，我们直接将这些方法默认抛出UnsupportedOperationException异常。

        安全模式：
            统一行为（Component）只规定系统各个层次的最基础的一致行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身当中

        如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。
        关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

        优点：
            组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
            更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；

        缺点：
            设计较复杂，客户端需要花更多时间理清类之间的层次关系；
            不容易限制容器中的构件；
            不容易用继承的方法来增加构件的新功能；

        抽象构件（Component）角色：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性
        树枝构件（Composite）角色：
            定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构，通常包含 Add()、Remove()、GetChild() 等方法
        树叶构件（Leaf）角色：叶子节点对象，其下再无分支，是系统层次遍历的最小单位

        使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。


    享元模式 (Flyweight)
        定义：通过共享的方式高效的支持大量细粒度的对象。
        简单来说：
            我们抽取出一个对象的外部状态（不能共享）和内部状态（可以共享），然后根据外部状态的决定是否创建内部状态对象。
            内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。

        内部状态：即不会随着环境的改变而改变的可共享部分。
        外部状态：指随环境改变而改变的不可以共享的部分。

        如何解决：
            用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
            用HashMap存储这些对象

        优点：
            大大减少对象的创建，降低系统的内存，使效率提高。

        缺点：
            共享对象可能会对线程安全造成问题。
            提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

        角色：
            Flyweight (享元抽象类)
            ConcreteFlyweight(具体享元类)
            FlyweightFactory(享元工厂类)



关系型模式（11种）

     策略模式 (Strategy)
        定义： 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。

        优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
        缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

        角色：
            抽象策略角色: 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。
            具体策略角色: 包装了具体的算法和行为。
            环境角色: 内部会持有一个抽象角色的引用，给客户端调用。

        策略模式最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。


    模板模式 (Template)
        定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

        通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。
        ————————————————

                                    版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

        原文链接：https://blog.csdn.net/A1342772/article/details/91349142


行为型模式
责任链模式Chain of Responsibility
问题
解决
命令模式Command
问题
解决
迭代器模式Iterator
问题
解决
中介者模式Mediator
问题
解决
备忘录模式Memento
问题
解决
观察者模式Observer
问题
解决
状态模式 State
问题
解决
策略模式
问题
解决
模板方法模式 Method
问题
解决
访问者模式Visitor
问题
解决