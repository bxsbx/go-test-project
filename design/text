设计模式的七大原则：

开闭原则：
    软件应该对扩展开放，对修改关闭。
作用：
    降低软件的维护成本，增加可扩展性。

里氏替换原则：
    里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化。
    子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
作用：
    里氏替换原则是实现开闭原则的重要方式之一。
    它克服了继承中重写父类造成的可复用性变差的缺点。
    它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

依赖倒置原则：
    面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象。
作用：
    降低类间的耦合性，使系统更适宜于扩展，也更便于维护。

单一职责原则：
    一个类应该只有一个发生变化的原因。职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
    如果一个对象承担了太多的职责，至少存在以下两个缺点：
        1、一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力
        2、当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费
    核心就是控制类的粒度大小、将对象解耦、提高其内聚性
    与接口隔离原则的区别：注重的是职责，主要是约束类，它针对的是程序中的实现和细节
作用
    降低类的复杂度、耦合度，提高类的内聚性
    提高代码的可读性，维护性
    减低代码出错的风险


接口分离原则：
    使用多个专门的接口，而不使用高耦合的单一接口。
    要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
    与单一职责原则的区别：注重的是对接口依赖的隔离，主要约束接口，主要针对抽象和程序整体框架的构建
作用
     降低接口的复杂度、耦合度


迪米特法则（最少知道原则）：
    一个实体应当尽量少地与其他实体之间发生相互作用。
    如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
    含义：只与你的直接朋友交谈，不跟“陌生人”说话。“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，
    这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
作用：
    为了降低耦合，提高模块的相对独立性。
    由于亲合度降低，从而提高了类的可复用率和系统的扩展性。


合成复用原则（组合/聚合复用原则）：
    软件复用时，要尽量先使用组合或者聚合等关联关系来实现
    通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用
作用：
    通常类的复用分为继承复用和合成复用两种.

    继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
    继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
    子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
    它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

    采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
    它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
    新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
    复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。



23种设计模式：


创建型模式（五种）:

    建议根据业务复杂度去使用对应的工厂模式
    两种实现方式（一种是传参数获取，一种是直接调方法获取）常用的是传参方式

    工厂方法模式 (Factory)
        1、简单工厂模式：（常用）
            定义：定义一个创建对象的类，由这个类来封装实例化对象的行为。
            存在的问题：如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则（问题不大）
            用来生产同一等级结构中的任意产品。（不支持拓展增加产品）
        2、工厂方法模式：（业务可用）
            定义：用一个工厂类管理各个子工厂类
            用来生产同一等级结构中的固定产品。（支持拓展增加产品）
        3、抽象工厂模式：（继承接口或抽象类） （简单来说就是工厂的工厂）（建议使用）
            定义：定义了一个接口或抽象类用于创建对象族（工厂），获取到工厂后，再决定获取对应的实例对象。
            优点：便于扩展
            用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）


    建造者模式 (Builder)
        定义：封装一个复杂对象构造过程，并允许按步骤构造。
        定义解释：一个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，
        但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离， 使用builder模式可以建立。

        四种角色：
        1、产品(Product)：要构造的复杂对象；
        2、抽象生成器(Bulider)：抽象生成器是一个接口，该接口除了为创建一个Product对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法（定义构造步骤）；
        3、具体生产器(ConcreteBuilder)：实现Builder接口的类，具体生成器将实现Builder接口所定义的方法（生产各个组件）；

        4、指挥者(Director)：指挥者是一个类，该类需要含有Builder接口声明的变量。
        指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的Product对象，
        如果所请求的具体生成器成功地构造出Product对象，指挥者就可以让该具体生产器返回所构造的Product对象。（按照步骤组装部件，并返回Product）

        优点：将一个对象分解为各个组件，将对象组件的构造封装起来，可以控制整个对象的生成过程
        缺点：对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量


    原型模式 (Clone)
        定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。（本质是Clone） （深拷贝和浅拷贝）

    单例模式 (Singleton)
        定义：确保一个类最多只有一个实例，并提供一个全局访问点
        单例模式可以分为两种：预加载和懒加载
        预加载:还没有使用该单例对象，就已经被加载到内存了。
        懒加载：需要保证线程安全性


结构型模式（7种）

    适配器模式 (Adapter)
        定义：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

        主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。
        类适配器模式：通过多重继承目标接口和被适配者类方式来实现适配。
        对象适配器模式：对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。
        接口适配器模式：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），
                    那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。

        类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
        对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
        接口适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。

        使用选择：根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。


    装饰模式 (Decorator)
        定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。
        简单解释：将对象封装到另一个对象中，用以为原对象绑定新的行为。
        角色：被装饰者与装饰者
        1.Component（被装饰对象的基类）
           定义一个对象接口，可以给这些对象动态地添加职责。
        2.ConcreteComponent（具体被装饰对象）
           定义一个对象，可以给这个对象添加一些职责。
        3.Decorator（装饰者抽象类）
           维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。
        4.ConcreteDecorator（具体装饰者）
           具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。

        装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。
        在这里应用继承并不是实现方法的复制,而是实现类型的匹配。
        因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。
        根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。


    代理模式 (Proxy)
        定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
        中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，
                   而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。
        开闭原则，增加功能：我们还可以通过给代理类增加额外的功能来扩展委托类的功能，通过调用委托类的相关方法，来提供特定的服务。
                    可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能。

        代理模式分为三类：
        1. 静态代理
            缺点：代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，造成太多的类存在。
        2. 动态代理 3. CGLIB代理 (go 语言没有，如需要得自己模拟实现)


    外观模式 (Facade)
        定义： 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。
        三种角色：
        　　1）.门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（客户调用，同时自身调用子系统功能）
        　　2）.子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）
        　　3）.客户角色:通过调用Facede来完成要实现的功能（调用门面角色）。
        优点：
            1、使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护
            2、有些方法是对系统外的，有些方法是系统内部相互交互的使用的。
                子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。

           　

    桥接模式 (Bridge)
        定义： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
        适用场景：
            当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
            当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
            当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。

        优点：
            (1)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，
                且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。
            (2)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。
        缺点：
            增加系统的理解与设计难度


    组合模式（对象树模式）(Object Tree)
        定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，
            用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
            可以利用多态和递归机制更方便地使用复杂树结构。

        意图：将对象组合成树形结构以表示"部分-整体"的层次结构。
            组合模式使得用户对单个对象和组合对象的使用具有一致性。

        透明组合模式：
            由于 Component 包含叶子节点所不需要的方法，因此，我们直接将这些方法默认抛出UnsupportedOperationException异常。

        安全模式：
            统一行为（Component）只规定系统各个层次的最基础的一致行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身当中

        如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。
        关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

        优点：
            组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
            更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；

        缺点：
            设计较复杂，客户端需要花更多时间理清类之间的层次关系；
            不容易限制容器中的构件；
            不容易用继承的方法来增加构件的新功能；

        抽象构件（Component）角色：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性
        树枝构件（Composite）角色：
            定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构，通常包含 Add()、Remove()、GetChild() 等方法
        树叶构件（Leaf）角色：叶子节点对象，其下再无分支，是系统层次遍历的最小单位

        使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。


    享元模式 (Flyweight)
        定义：通过共享的方式高效的支持大量细粒度的对象。
        简单来说：
            我们抽取出一个对象的外部状态（不能共享）和内部状态（可以共享），然后根据外部状态的决定是否创建内部状态对象。
            内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。

        内部状态：即不会随着环境的改变而改变的可共享部分。
        外部状态：指随环境改变而改变的不可以共享的部分。

        如何解决：
            用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
            用HashMap存储这些对象

        优点：
            大大减少对象的创建，降低系统的内存，使效率提高。

        缺点：
            共享对象可能会对线程安全造成问题。
            提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

        角色：
            Flyweight (享元抽象类)
            ConcreteFlyweight(具体享元类)
            FlyweightFactory(享元工厂类)



关系型模式（11种）

     策略模式 (Strategy)
        定义： 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。

        优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
        缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

        角色：
            抽象策略角色: 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。
            具体策略角色: 包装了具体的算法和行为。
            环境角色: 内部会持有一个抽象角色的引用，给客户端调用。

        策略模式最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。


    模板模式 (Template)
        定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

        优点：
        　  具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构。
        　  存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”。

        缺点：
            每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。

        抽象父类（AbstractClass）：实现了模板方法，定义了算法的骨架。
        具体类（ConcreteClass)：实现抽象类中的抽象方法，即不同的对象的具体实现细节。


    观察者模式 (发布-订阅模式) (Observer)
        定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
        优点：
            1、观察者和被观察者是抽象耦合的。
            2、由于被观察者对象并不关心具体的观察者是谁，所以在程序运行的过程中，可以动态地增加或者删除观察者对象，增加了灵活性。
            3、符合开闭原则，当需要添加新的观察者时，只需要添加一个实现观察者接口的类，而不需要修改被观察者对象的代码
        缺点：
            1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
            2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
            3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

        角色：
            抽象被观察者角色：(Subject)
                也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。
                抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
            具体被观察者角色：
                也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
            抽象观察者角色：(Observer)
                为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
            具体观察者角色：
                实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。



    迭代器模式 (Iterator) 比较少使用（go中更少使用）
        定义：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
        优点：
            1、它支持以不同的方式遍历一个聚合对象。
            2、迭代器简化了聚合类。
            3、在同一个聚合上可以有多个遍历。
            4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

        缺点：
            由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，
            类的个数成对增加，这在一定程度上增加了系统的复杂性。

        角色：
            迭代器角色（Iterator）:定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法next()，判断是否遍历结束的方法hasNext()），移出当前对象的方法remove(),
            具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。
            容器角色(Aggregate):  一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等
            具体容器角色（ConcreteAggregate）：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。



    责任链模式 (Responsibility)
        定义：如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。
        主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
        优点：
            降低耦合度：请求发送者和接收者都没有对方的明确信息，而是通过抽象处理器来链接。实现了请求的发送者和处理者之间的解耦。
            灵活性：可以动态地增加或删除处理器，方便扩展和维护。
            易于实现: 在责任链模式中，每个具体的处理器只需要实现自己的功能即可，不需要知道整个请求链的存在，这样更加容易实现其功能。
        缺点：
            不能保证请求一定会被处理：在责任链模式中，由于请求的处理是由多个对象负责的，所以不能保证请求一定会被处理，存在漏洞导致请求无响应的风险。
            性能问题：在应用责任链模式时需要控制链中的处理器数量，过多的处理器会导致处理时间增加，从而影响系统性能。
            调试困难：责任链模式中的处理器是动态组合的，处理逻辑较为复杂，因此需要进行详细的测试和调试。

        角色：
            抽象处理者（Handler）：
                定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
            具体处理者（Concrete Handler）：
                实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
            客户类（Client）：
                创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。



    命令模式 (Command)
        定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
            这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。
        意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。
        主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，
            但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。
        如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。

        角色：
            抽象命令类（Command）：声明执行命令的接口，拥有执行命令的抽象方法 execute()。
            具体命令角色（ConcreteCommand）：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
            实现者/接收者（Receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
            调用者/请求者（Invoker）：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。

        优点：
            解耦：命令模式可以将发送命令的对象和执行命令的对象解耦，使得两者可以独立变化。
            可扩展性：可以方便地添加新的命令类和接收者类，而无需修改现有的代码结构。
            容易实现撤销和重做功能：由于每个命令对象都封装了具体的操作，可以很容易地实现命令的撤销和重做功能。
            支持操作的队列化和延迟执行：命令对象可以被组织成队列或堆栈，实现对操作的排队和延迟执行。
        缺点：
            增加了类和对象的数量：使用命令模式可能会增加一些新的类和对象，从而增加了代码的复杂性。
            需要额外的开销：封装命令对象和操作会增加一些额外的开销，可能会稍微降低性能。
            可能导致过多的具体命令类：如果系统的命令比较多，可能会导致需要创建很多具体的命令类，增加了代码维护的难度。


    状态模式 (State)
        定义： 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
        主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。
        优点：
            1、客户端只需要与上下文对象进行交互，而不需要了解具体状态对象的切换和行为实现细节。
            2、避免了使用大量的条件语句来控制对象在不同状态下的行为。它将状态相关的代码分散到各个具体状态类中，使代码更加清晰、可读性更高，易于维护和扩展。
            3、状态转换被封装在具体状态类中，可根据需求定义不同的状态切换规则，使得状态转换过程可控、灵活。

        缺点：
            1、状态模式的使用必然会增加系统类和对象的个数。
            2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
            3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，
                否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

        角色：
            抽象状态角色(State):接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。
            具体状态角色(ConcreteState):具体状态主要有两个职责：一是处理本状态下的事情，二是从本状态如何过渡到其他状态。
            环境角色(Context):定义客户端需要的接口，并且负责具体状态的切换。



    备忘录模式 (Memento) (快照模式)
        定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
        优点：
            提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
            实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
            发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。

        缺点：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

        角色：
            发起人（Originator）：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
            备忘录（Memento）：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
            管理者（Caretaker）：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。


    访问者模式 (Visitor)
        定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，
            为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。
        优点：
            扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
            复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
            灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
            符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。

        缺点：
            增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
            破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
            违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

        角色：
            抽象访问者（Visitor）：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
            具体访问者（ConcreteVisitor）：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
            抽象元素（Element）：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
            具体元素（ConcreteElement）：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
            对象结构（Object Structure）：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。


    中介者模式(Mediator)
        定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。
        优点：
            降低了对象之间的耦合性，使得对象易于独立地被复用。
            将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。

        缺点：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。

        角色：
            抽象中介者（Mediator）：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
            具体中介者（ConcreteMediator）：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
            抽象同事类（Colleague）：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
            具体同事类（Concrete Colleague）：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。


    解释器模式（Interpreter）
        定义：解释器使用该表示来解释语言中的句子。
            解释器中涉及到的文法，就是符合一定规则的语句结构.其实质是把语言中的每个符号定义成一个（对象）类，从而把每个程序转换成一个具体的对象树。

        优点：
            易于改变和扩展文法：由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。
            实现文法较为容易：在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。
            增加新的解释表达式较为方便：如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。

        缺点：
            对于复杂文法难以维护：在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。
            执行效率较低：由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。

        角色：
            抽象表达式（Abstract Expression）：声明了一个抽象的解释操作，通常是一个接口或者抽象类。
            终结符表达式（Terminal Expression）：实现了与文法中的终结符相关联的解释操作。
            非终结符表达式（Nonterminal Expression）：对文法中的非终结符号进行解释操作。一般包含终结符、非终结符表达式
            上下文（Context）：包含解释器之外的一些全局信息。
            客户端（Client）：构建表示该语言的抽象语法树，调用解释操作来解释这棵树。


